var documenterSearchIndex = {"docs":
[{"location":"guards/#Understanding-Guards","page":"Understanding Guards","title":"Understanding Guards","text":"","category":"section"},{"location":"guards/","page":"Understanding Guards","title":"Understanding Guards","text":"CurrentModule = Guards","category":"page"},{"location":"guards/","page":"Understanding Guards","title":"Understanding Guards","text":"Guards is an Actors protocol. It solves the mutual exclusion problem for shared variables:","category":"page"},{"location":"guards/","page":"Understanding Guards","title":"Understanding Guards","text":"The mutual exclusion problem arises when two processes should never simultaneously access a shared resource. ... Although, a single receptionist may control access to a resource, the resource itself can still be modeled as a system of actors so that there may be concurrency in the use of the resource. ... In general, a programmer using an actor language need not be concerned with the mutual exclusion problem. [1]","category":"page"},{"location":"guards/","page":"Understanding Guards","title":"Understanding Guards","text":"As for now a :guard actor is a \"single receptionist\" in Agha's sense controlling access to a resource or similar to an agent in Elixir. The variable is protected by message passing and the :guard actor being the only entity allowed to modify it. It generally returns only deep copies. So e.g. threads can safely do iterations on those.","category":"page"},{"location":"guards/#Interfaces","page":"Understanding Guards","title":"Interfaces","text":"","category":"section"},{"location":"guards/","page":"Understanding Guards","title":"Understanding Guards","text":"[1]: Gul Agha: Actors, ch 6.1.3, p.95","category":"page"},{"location":"api/#Guards-API","page":"Guards API","title":"Guards API","text":"","category":"section"},{"location":"api/","page":"Guards API","title":"Guards API","text":"CurrentModule = Guards","category":"page"},{"location":"api/","page":"Guards API","title":"Guards API","text":"Modules = [Guards]","category":"page"},{"location":"api/#Guards.Guards","page":"Guards API","title":"Guards.Guards","text":"Guards\n\nImplements a generic server Actor's protocol.\n\nThe current stable, registered version is installed with\n\npkg> add Guards\n\nThe development version is installed with:\n\npkg> add \"https://github.com/JuliaActors/Guards.jl\"\n\n\n\n\n\n","category":"module"},{"location":"api/#Guards.version","page":"Guards API","title":"Guards.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Guards.Guard","page":"Guards API","title":"Guards.Guard","text":"Guard{T}\n\nA parametric struct returned by guard.\n\nParameter/Field\n\nT: the type of the guarded variable,\nlink::Union{Link,Symbol}: Link or name of guard actor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.call-Tuple{Guards.Guard,Any,Vararg{Any,N} where N}","page":"Guards API","title":"Actors.call","text":"call(gd::Guard, f, args...)\n\nCall a guard actor gd to execute f(var, args...) on   its guarded variable var and to send respond with a  deep copy of the result. \n\nArguments\n\ngd::Guard: link to the :guard actor,\nf: callable object taking the guarded variable var   as first argument,\nargs...: further arguments to f.\n\n\n\n\n\n","category":"method"},{"location":"api/#Actors.cast-Tuple{Guards.Guard,Any,Vararg{Any,N} where N}","page":"Guards API","title":"Actors.cast","text":"cast(gd::Guard, f, args...)\n\nCast a message to a guard actor gd to execute f(var, args...) on   its guarded variable var.\n\nArguments\n\ngd::Guard: link to the :guard actor,\nf: callable object taking the guarded variable var   as first argument,\nargs...: further arguments to f.\n\n\n\n\n\n","category":"method"},{"location":"api/#Guards.guard-Tuple{Any}","page":"Guards API","title":"Guards.guard","text":"guard(var;  name=nothing, pid=myid(), thrd=false, \n            sticky=false, taskref=nothing)\n\nStart a :guard actor for the variable var and return  a Guard link to it.\n\nParameters\n\nvar: variable to guard for,\nname=nothing: if a name::Symbol is provided the server    is registered and the name is returned,\npid=myid(): worker pid to create the actor on,\nthrd=false: thread to create the actor on,\nsticky=false: if true, the actor is created in    the same thread,\ntaskref=nothing: if a Ref{Task} variable is    provided, it gets the created Task.  \n\n\n\n\n\n","category":"method"},{"location":"api/#Guards.@grd-Tuple{Any}","page":"Guards API","title":"Guards.@grd","text":"@grd gd\n@grd f(gd, args...)\n\nReturn a deep copy of a guarded variable var or of the  result of a function call on it. This is a wrapper to call.\n\nParameters\n\ngd::Guard: a link to the :guard actor,\nf: callable object taking the guarded variable var    as first argument,\nargs...:  further arguments to f.\n\n\n\n\n\n","category":"macro"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Guards","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In order to secure a mutable variable from concurrent access by multiple threads and/or distributed workers you call guard on it. That wraps it into a :guard actor represented only by a Guard link.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Then it can be accessed only by message passing via cast and call over that link. Calls to it return deep copies. You can still modify a guarded variable by sending the :guard actor a modifier function and arguments to it.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The @grd macro expands a call to the link into a call request.","category":"page"},{"location":"intro/#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> using Guards\n\njulia> gd = guard([1,2,3])  # start a guard actor around an array\nGuards.Guard{Array{Int64,1}}(Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :guard))\n\njulia> call(gd)             # get a deep copy of it\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> push!(call(gd), 4)   # pushing to it ...\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> call(gd)             # the guarded variable has not changed\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> call(gd, push!, 4);  # if you call it with push!,\n\njulia> @grd gd              # ... it got changed (here using the @grd macro)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> @grd pop!(gd)        # pop! with the macro\n4","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Guards","category":"page"},{"location":"#Guards","page":"Home","title":"Guards","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let actors guard your mutable variables!","category":"page"},{"location":"","page":"Home","title":"Home","text":"With Guards you can wrap mutable variables into a :guard actor. That way they can be safely accessed from parallel threads and distributed worker processes via message passing.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Introduction\nUnderstanding Guards\nGuards API","category":"page"},{"location":"#Authors(s)","page":"Home","title":"Authors(s)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paul Bayer","category":"page"},{"location":"","page":"Home","title":"Home","text":"Guards is part of JuliaActors, license: MIT","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
